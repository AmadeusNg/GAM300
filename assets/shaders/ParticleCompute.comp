#version 450 core

struct Particle {
    //transform params
    vec3 Size;//xyz scale of the particle
    vec3 Rotation;
    vec3 CurrentPosition;// constant transform position of the entity, position of particle is an offset from here based on velocity and acceleration
    
    //movement params
    vec3 Velocity;
    vec3 Acceleration;
    float Age;//how long has the particle been active
    
    //aesthetics params
    vec3 Color;//rgb color of the particle
    bool Active;//is the particle active
};

layout (std140, binding = 1) buffer Particles {
    Particle List[];
}Particles;

layout (std140, binding = 2) buffer Freelist{
    int count;
    int indices[];
}Freelist;

layout (std140, binding = 3) writeonly buffer v_TransformMatrix{
    mat4 List[];
}v_TransformMatrix;

layout (location = 1 ) uniform float DeltaTime;

mat4 GenerateTransform(vec3 Scale, vec3 Rotate, vec3 Translate){
    mat4 Scalemat{
        Scale.x, 0.0, 0.0, 0.0,
        0.0, Scale.y, 0.0, 0.0,
        0.0, 0.0, Scale.z, 0.0,
        0.0, 0.0, 0.0, 1.0};
    
    mat4 rotationX{
        1.0, 0.0, 0.0, 0.0,
        0.0, cos(Rotate.x), -sin(Rotate.x), 0.0,
        0.0, sin(Rotate.x), cos(Rotate.x), 0.0,
        0.0, 0.0, 0.0, 1.0
    };

    mat4 rotationY{
        cos(Rotate.y), 0.0, sin(Rotate.y), 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sin(Rotate.y), 0.0, cos(Rotate.y), 0.0,
        0.0, 0.0, 0.0, 1.0
    };

    mat4 rotationZ{
        cos(Rotate.z), -sin(Rotate.z), 0.0, 0.0,
        sin(Rotate.z), cos(Rotate.z), 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
    };

    mat4 Rotmat = rotationZ * rotationY * rotationX;

    mat4 Translatemat{
        1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        Translate.x, Translate.y, Translate.z, 1.0
    }

    mat4 Xform = Translatemat* Rotmat* Scalemat;
    return Xform;
}

void ComputeParticle(inout Particle p, int index){
    if (p.Age > 0.0){
        p.Age -= DeltaTime;
        p.Velocity += p.Acceleration * DeltaTime;
        p.CurrentPosition += p.Velocity * DeltaTime;

        if (p.Age <= 0.0){
            p.Active = false;
            Freelist.indices[atomicAdd(Freelist.count,1)] = index;
        }
    }
}


layout(local_size_x =128, local_size_y = 1, local_size_z = 1) in;

void main(){
    uint index = gl_GlobalInvocationID.x;
    if (index >= Particles.List.length()){
        return;
    }
    ComputeParticle(Particle.List[index], index);

    v_ParticleXform.list[index] = GenerateTransform(Particle.List[index].Size, Particle.List[index].Rotation, Particle.List[index].CurrentPosition);
}